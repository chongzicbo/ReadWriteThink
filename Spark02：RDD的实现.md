## 1.作业调度

在执行转换操作的RDD时，调度器会根据RDD的“血统”来构建若干由stage组成的有向无环图(DAG),每个stage阶段包含若干个连续窄依赖转换。调度器按照DAG顺序进行计算得到最终的RDD。

调度器向各节点分配任务采用延时调度机制并根据数据存储位置(数据本地性)来确定。如果一个任务需要处理的某个分区刚好存储在相应节点的内存中，则该任务会分配给该节点；如果在内存中不包含该分区，调度器会找到包含该RDD的较佳位置，并把任务分配给所在节点。

<img src="http://qfth8dccq.hn-bkt.clouddn.com/images/image-20200826103555542.png" alt="image-20200826103555542" style="zoom:50%;" />

对于宽依赖而言，Spark会将中间结果物化到父分区的节点上，这样可以简化数据的故障恢复过程。如上图所示，stage是根据宽依赖来划分Stage，对各调度阶段内部的窄依赖则前后连接构成流水线。图中，A和B是宽依赖，所以A划分为一个stage,F与G之间也是宽依赖，所以C、D、E和F划分为一个stage。最后所有的RDD组成一个stage。在本例中，Stage1的输出已经存在内存中，所以直接执行Stage2，然后执行Stage3。

对于执行失败的任务，只要它对应调度阶段父类信息仍然可用，该任务会分散到其它节点重新执行。如果某些调度阶段不可用(例如，因为shuffle在map节点丢失了)，则重新提交相应的任务，并以并行方式计算丢失的分区。在作业中，如果某个任务执行缓慢(Straggler),系统会在其他节点上执行该任务的副本，并取最先得到的结果作为最终的结果。

## 2.内存管理

Spark提供了2种持久化RDD的存储策略：

| 持久化策略                 |                                                              |
| -------------------------- | ------------------------------------------------------------ |
| 未序列化Java对象存在内存中 | 性能最优，可以直接访问在java虚拟机内存里的对象               |
| 序列化的数据存于内存中     | 空间有限的情况下，可以让用户采用比java对象更有效的组织方式，但降低了性能 |
| 存于磁盘                   | 用于RDD太大的情形，每次重新计算该RDD会带来额外的资源开销(如I/O) |

内存管理使用LRU回收算法，当计算得到一个新的RDD分区，但没有足够空间，系统会从最近最少使用的RDD回收其一个分区的空间。除非该RDD是新分区对应的RDD，这种情况下Spark会将旧的分区继续保留在内存中，防止同一个RDD的分区被循环调入/调出。

## 3. 检查点(Checkpoint)支持

对于很长的"血统"的RDD来说，如果需要回复错误RDD，则需要很长时间，因此需要通过检查点操作将RDD保存到外部存储中。对于包含宽依赖的长“血统”,当集群中某个节点出现故障时，会使得从各个父RDD计算出的数据丢失，造成重新计算，因此，设置检查点就显得有必要。对于窄依赖的RDD，对其进行检查点操作就不是必须的。因为，如果一个节点发生故障，RDD在该节点中丢失的分区数据可以通过并行的方式从其它节点中计算出来，成本只是复制RDD的很小部分。

## 4.多用户管理

RDD模型将计算分解为多个相互独立的细粒度任务，使得它在多用户集群能够支持多种资源共享算法。每个RDD应用可以在执行过程中动态调整访问资源。

* 在每个应用程序中，Spark运行多线程同时提交作业，并通过一种等级公平调度器来实现多个作业对集群资源的共享。
* Spark的公平调度也使用延迟调度，通过轮询每台机器的数据，在保持公平的情况下给予本地作业高的本地性。Spark支持多级本地化访问策略(本地化),包括内存、磁盘和机架。
* 由于任务相互独立，调度器还支持取消作业来为高优先级的作业腾出资源。
* Spark可以使用Mesos来实现细粒度的资源共享，使得Spark应用能相互之间或在不同的计算框架之间实现资源的动态共享。
* Spark使用Sparrow系统扩展支持分布式调度，该调度允许多个Spark应用以去中心化的方式在同一集群上排队工作，同时提供本地性、低延迟和公平性。