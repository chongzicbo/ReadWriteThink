---
title: 'C++常量与指针和引用的结合'
categories:
  - [开发,cpp]
tags:
  - c++
  - cpp
  - c++基础
---

## C++常量与指针和引用的结合

### 1. 引言

在C++编程中，常量、指针和引用是三个非常重要的概念。常量用于定义不可修改的值，指针用于存储变量的内存地址，而引用则是变量的别名。将常量与指针和引用结合使用，可以提高代码的安全性和可读性，同时也能更好地控制内存管理。

常量与指针、引用的结合使用在实际编程中非常常见，尤其是在需要保护数据不被意外修改的场景中。通过使用常量指针和常量引用，可以确保数据在特定上下文中不会被修改，从而提高代码的健壮性和可维护性。

---

### 2. 常量指针

#### 2.1 常量指针的基本概念

**常量指针**是指针本身是一个常量，即指针指向的地址不能改变，但指针所指向的内容可以修改。常量指针的定义方式是在指针类型前加上 `const` 关键字。

**代码示例：**

```cpp
#include <iostream>

int main() {
    int a = 10;
    int b = 20;

    // 定义一个常量指针，指向变量 a
    int* const ptr = &a;

    // 通过常量指针修改 a 的值
    *ptr = 30;  // 合法，因为指针指向的内容可以修改

    // ptr = &b;  // 非法，因为常量指针不能改变指向的地址

    std::cout << "a = " << a << std::endl;  // 输出：a = 30

    return 0;
}
```

**代码解析：**

- `int* const ptr = &a;`：定义了一个常量指针 `ptr`，它指向变量 `a`。
- `*ptr = 30;`：通过指针修改 `a` 的值是合法的，因为常量指针指向的内容可以修改。
- `ptr = &b;`：试图改变指针的指向是非法的，因为常量指针的指向地址不能改变。

**使用场景：**

常量指针常用于需要固定指针指向的场景，例如在函数中传递指针参数时，确保指针不会指向其他地址。

---

#### 2.2 指向常量的指针

**指向常量的指针**是指针指向的内容是常量，即指针所指向的内容不能修改，但指针本身可以改变指向。指向常量的指针的定义方式是在指针类型后加上 `const` 关键字。

**代码示例：**

```cpp
#include <iostream>

int main() {
    int a = 10;
    int b = 20;

    // 定义一个指向常量的指针，指向变量 a
    const int* ptr = &a;

    // *ptr = 30;  // 非法，因为指针指向的内容是常量，不能修改

    ptr = &b;  // 合法，因为指针本身可以改变指向

    std::cout << "b = " << *ptr << std::endl;  // 输出：b = 20

    return 0;
}
```

**代码解析：**

- `const int* ptr = &a;`：定义了一个指向常量的指针 `ptr`，它指向变量 `a`。
- `*ptr = 30;`：试图修改指针指向的内容是非法的，因为指针指向的内容是常量。
- `ptr = &b;`：改变指针的指向是合法的，因为指针本身可以改变指向。

**使用场景：**

指向常量的指针常用于需要保护数据不被修改的场景，例如在函数参数中传递指针时，确保函数内部不会修改指针指向的内容。

---

#### 2.3 常量指针与指向常量的指针的区别

**常量指针**和**指向常量的指针**的区别在于：

- **常量指针**：指针本身是常量，指向的地址不能改变，但指向的内容可以修改。
- **指向常量的指针**：指针指向的内容是常量，不能修改，但指针本身可以改变指向。

**代码示例：**

```cpp
#include <iostream>

int main() {
    int a = 10;
    int b = 20;

    // 常量指针
    int* const ptr1 = &a;
    *ptr1 = 30;  // 合法
    // ptr1 = &b;  // 非法

    // 指向常量的指针
    const int* ptr2 = &a;
    // *ptr2 = 30;  // 非法
    ptr2 = &b;  // 合法

    std::cout << "a = " << a << ", b = " << *ptr2 << std::endl;  // 输出：a = 30, b = 20

    return 0;
}
```

**代码解析：**

- `int* const ptr1 = &a;`：常量指针，指向的地址不能改变，但指向的内容可以修改。
- `const int* ptr2 = &a;`：指向常量的指针，指向的内容不能修改，但指针本身可以改变指向。

**适用场景：**

- **常量指针**：适用于需要固定指针指向的场景。
- **指向常量的指针**：适用于需要保护数据不被修改的场景。

**如何区分：**

- **`const` 在 `*` 的左边**：
  - 表示指针指向的内容是常量，不能通过指针修改。
  - 语法：`const int* ptr;`
  - 含义：`ptr` 是一个指针，指向的内容是常量 `int`。
- **`const` 在 `*` 的右边**：
  - 表示指针本身是常量，不能改变指针的指向。
  - 语法：`int* const ptr;`
  - 含义：`ptr` 是一个常量指针，指向 `int`。

#### 2.4 指向常量的常量指针

##### 2.4.1 指向常量的常量指针的基本概念

**指向常量的常量指针**是一种结合了常量指针和指向常量的指针的特性。它既不能改变指针的指向，也不能通过指针修改所指向的内容。换句话说，指针本身是常量，同时指针指向的内容也是常量。

**定义方式：**

```cpp
const int* const ptr;
```

- `const int*`：表示指针指向的内容是常量，不能通过指针修改。
- `const ptr`：表示指针本身是常量，不能改变指针的指向。

##### 2.4.2 代码示例和代码解析

**代码示例：**

```cpp
#include <iostream>

int main() {
    int a = 10;
    int b = 20;

    // 定义一个指向常量的常量指针，指向变量 a
    const int* const ptr = &a;

    // *ptr = 30;  // 非法，因为指针指向的内容是常量，不能修改
    // ptr = &b;   // 非法，因为指针本身是常量，不能改变指向

    std::cout << "Value of a: " << *ptr << std::endl;  // 输出：Value of a: 10

    return 0;
}
```

**代码解析：**

- `const int* const ptr = &a;`：定义了一个指向常量的常量指针 `ptr`，它指向变量 `a`。
- `*ptr = 30;`：试图通过指针修改 `a` 的值是非法的，因为指针指向的内容是常量。
- `ptr = &b;`：试图改变指针的指向是非法的，因为指针本身是常量。

**使用场景：**

指向常量的常量指针常用于需要严格保护数据的场景，例如在函数参数中传递指针时，确保指针和指针指向的内容都不会被修改。

---

##### 2.4.3 指向常量的常量指针与其他指针类型的对比

为了更好地理解指向常量的常量指针，我们可以将其与其他指针类型进行对比：

| 指针类型           | 指针本身是否可变 | 指针指向的内容是否可变 |
| ------------------ | ---------------- | ---------------------- |
| 普通指针           | 是               | 是                     |
| 常量指针           | 否               | 是                     |
| 指向常量的指针     | 是               | 否                     |
| 指向常量的常量指针 | 否               | 否                     |

**代码示例：**

```cpp
#include <iostream>

int main() {
    int a = 10;
    int b = 20;

    // 普通指针
    int* ptr1 = &a;
    *ptr1 = 30;  // 合法
    ptr1 = &b;   // 合法

    // 常量指针
    int* const ptr2 = &a;
    *ptr2 = 40;  // 合法
    // ptr2 = &b;  // 非法

    // 指向常量的指针
    const int* ptr3 = &a;
    // *ptr3 = 50;  // 非法
    ptr3 = &b;   // 合法

    // 指向常量的常量指针
    const int* const ptr4 = &a;
    // *ptr4 = 60;  // 非法
    // ptr4 = &b;   // 非法

    std::cout << "a = " << a << ", b = " << b << std::endl;  // 输出：a = 40, b = 20

    return 0;
}
```

**代码解析：**

- `int* ptr1 = &a;`：普通指针，指针本身和指向的内容都可以修改。
- `int* const ptr2 = &a;`：常量指针，指针本身不能修改，但指向的内容可以修改。
- `const int* ptr3 = &a;`：指向常量的指针，指针本身可以修改，但指向的内容不能修改。
- `const int* const ptr4 = &a;`：指向常量的常量指针，指针本身和指向的内容都不能修改。

**适用场景：**

- **普通指针**：适用于需要灵活修改指针和指针指向内容的场景。
- **常量指针**：适用于需要固定指针指向的场景。
- **指向常量的指针**：适用于需要保护数据不被修改的场景。
- **指向常量的常量指针**：适用于需要严格保护数据和指针的场景。

---

##### 2.4.4 指向常量的常量指针的实际应用

指向常量的常量指针在实际编程中常用于需要严格保护数据的场景，例如在函数参数中传递指针时，确保指针和指针指向的内容都不会被修改。

**代码示例：**

```cpp
#include <iostream>

void printValue(const int* const ptr) {
    // *ptr = 100;  // 非法，指针指向的内容是常量
    // ptr = nullptr;  // 非法，指针本身是常量

    std::cout << "Value: " << *ptr << std::endl;
}

int main() {
    int a = 10;

    printValue(&a);

    return 0;
}
```

**代码解析：**

- `const int* const ptr`：指向常量的常量指针，确保函数内部不会修改指针和指针指向的内容。

**使用场景：**

常用于需要严格保护数据的场景，例如在函数参数中传递指针时，确保指针和指针指向的内容都不会被修改。

通过以上内容，我们可以看到指向常量的常量指针是一种非常严格的指针类型，它结合了常量指针和指向常量的指针的特性，适用于需要严格保护数据的场景。

---

### 3. 常量引用

#### 3.1 常量引用的基本概念

**常量引用**是指引用所绑定的对象是常量，即引用不能修改所绑定对象的值。常量引用的定义方式是在引用类型前加上 `const` 关键字。

**代码示例：**

```cpp
#include <iostream>

int main() {
    int a = 10;

    // 定义一个常量引用，绑定到变量 a
    const int& ref = a;

    // ref = 20;  // 非法，因为引用是常量，不能修改所绑定对象的值

    std::cout << "a = " << a << std::endl;  // 输出：a = 10

    return 0;
}
```

**代码解析：**

- `const int& ref = a;`：定义了一个常量引用 `ref`，它绑定到变量 `a`。
- `ref = 20;`：试图通过引用修改 `a` 的值是非法的，因为引用是常量。

**使用场景：**

常量引用常用于函数参数中，以确保函数内部不会修改传入的参数。

---

#### 3.2 常量引用与普通引用的区别

**常量引用**和**普通引用**的区别在于：

- **常量引用**：引用所绑定的对象是常量，不能通过引用修改对象的值。
- **普通引用**：引用所绑定的对象可以修改。

**代码示例：**

```cpp
#include <iostream>

int main() {
    int a = 10;

    // 普通引用
    int& ref1 = a;
    ref1 = 20;  // 合法

    // 常量引用
    const int& ref2 = a;
    // ref2 = 30;  // 非法

    std::cout << "a = " << a << std::endl;  // 输出：a = 20

    return 0;
}
```

**代码解析：**

- `int& ref1 = a;`：普通引用，可以修改所绑定对象的值。
- `const int& ref2 = a;`：常量引用，不能修改所绑定对象的值。

**适用场景：**

- **普通引用**：适用于需要修改所绑定对象的场景。
- **常量引用**：适用于需要保护所绑定对象不被修改的场景。

---

### 4. 常量指针与常量引用的结合使用

#### 4.1 常量指针与常量引用的结合

常量指针和常量引用可以结合使用，以确保数据在特定上下文中不会被修改。这种结合使用常用于函数参数中，以提高代码的安全性和可读性。

**代码示例：**

```cpp
#include <iostream>

void printValue(const int* const ptr, const int& ref) {
    // *ptr = 100;  // 非法，指针指向的内容是常量
    // ptr = nullptr;  // 非法，指针本身是常量
    // ref = 200;  // 非法，引用所绑定的对象是常量

    std::cout << "Value from pointer: " << *ptr << std::endl;
    std::cout << "Value from reference: " << ref << std::endl;
}

int main() {
    int a = 10;

    printValue(&a, a);

    return 0;
}
```

**代码解析：**

- `const int* const ptr`：常量指针，指向的内容和指针本身都不能修改。
- `const int& ref`：常量引用，所绑定的对象不能修改。

**使用场景：**

常用于函数参数中，以确保函数内部不会修改传入的数据。

---

#### 4.2 常量指针与常量引用的安全性

结合使用常量指针和常量引用可以提高代码的安全性，因为它们可以防止数据被意外修改。然而，仍然需要注意潜在的安全问题，例如指针悬空和引用绑定到临时对象。

**代码示例：**

```cpp
#include <iostream>

int main() {
    int* ptr = new int(10);
    const int& ref = *ptr;

    delete ptr;  // 释放内存

    // 此时 ref 绑定到一个悬空指针，访问 ref 会导致未定义行为
    // std::cout << ref << std::endl;  // 不安全

    return 0;
}
```

**代码解析：**

- `delete ptr;`：释放指针指向的内存后，引用 `ref` 绑定到一个悬空指针，访问 `ref` 会导致未定义行为。

**如何避免潜在的安全问题：**

- 确保指针和引用在使用期间始终有效。
- 使用智能指针（如 `std::shared_ptr` 或 `std::unique_ptr`）来管理动态内存。

---

### 5. 常量指针和引用的实际应用

#### 5.1 在函数参数中的应用

常量指针和引用常用于函数参数中，以确保函数内部不会修改传入的数据。

**代码示例：**

```cpp
#include <iostream>

void printArray(const int* arr, int size) {
    for (int i = 0; i < size; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    printArray(arr, 5);

    return 0;
}
```

**代码解析：**

- `const int* arr`：指向常量的指针，确保函数内部不会修改数组元素。

**使用场景：**

常用于需要传递数组或大型数据结构的场景，以提高代码的安全性。

---

#### 5.2 在类成员中的应用

常量指针和引用常用于类成员中，以确保类成员不会被意外修改。

**代码示例：**

```cpp
#include <iostream>

class MyClass {
public:
    MyClass(const int* ptr, const int& ref) : ptr_(ptr), ref_(ref) {}

    void printValues() const {
        std::cout << "Pointer value: " << *ptr_ << std::endl;
        std::cout << "Reference value: " << ref_ << std::endl;
    }

private:
    const int* ptr_;  // 常量指针
    const int& ref_;  // 常量引用
};

int main() {
    int a = 10;
    MyClass obj(&a, a);
    obj.printValues();

    return 0;
}
```

**代码解析：**

- `const int* ptr_`：常量指针，确保类成员不会修改指针指向的内容。
- `const int& ref_`：常量引用，确保类成员不会修改引用所绑定的对象。

**使用场景：**

常用于需要保护类成员数据的场景，以提高代码的健壮性。

---

### 6. 总结

常量指针和常量引用是C++中非常重要的概念，它们可以提高代码的安全性和可读性。通过结合使用常量指针和常量引用，可以确保数据在特定上下文中不会被修改，从而提高代码的健壮性和可维护性。

- **常量指针**：指针本身是常量，指向的地址不能改变，但指向的内容可以修改。
- **指向常量的指针**：指针指向的内容是常量，不能修改，但指针本身可以改变指向。
- **常量引用**：引用所绑定的对象是常量，不能通过引用修改对象的值。

在实际编程中，常量指针和引用常用于函数参数和类成员中，以确保数据不会被意外修改。

文章合集：[chongzicbo/ReadWriteThink: 博学而笃志，切问而近思 (github.com)](https://github.com/chongzicbo/ReadWriteThink/tree/main)

个人博客：[程博仕](https://chongzicbo.github.io/)

微信公众号：

![微信公众号](https://raw.githubusercontent.com/chongzicbo/images/main/picgo/%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg)